<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小记]]></title>
    <url>%2Fdiary%2F181213%2F</url>
    <content type="text"><![CDATA[向上的路从来不拥挤。 博客是个好东西，还是要坚持记，没有粉丝，算是我一个私密的平台hhh…用来偶尔记录一些我的感想体会，还有技术文章。 最近感慨颇多，虽然感觉自己这一段时间，暴露出来的问题很多，但是感觉自己这段时间的收获也非常大，仔细回想起来，应该是因为接触的各类信息很多，整个的见识还有对世界的了解变得更清晰和客观，对于很多发生的事情和别人的经历，我也会去仔细的琢磨，真的是会很仔细地去分析，去借鉴或者感悟，学会慢慢从自己认知的小世界里走出来。一小点的量变引起了一小小点的质变了吧，hhhhh…. 自己有一个坚持了一段时间的习惯，觉得还不错，就是每天坚持了解一些自己原先不知道的东西，有时候是知识，有时候是见识。我对经济、资本市场、自我成长方面还有对一些时事轶事的深度分析比较感兴趣，每天都会拿出不少时间来学习，主要是看一些公众号的文章，自己不是大佬，就先跟着大佬的观点去分析和认知，觉得很受启发。更让我比较开心的是我不会觉得这是一种负担，而是兴趣所在，并且我隐隐觉得迈出了这第一步，后边习惯成自然会轻松的多。 我也不会去再去想，了解这么多到底有没有用，我一个学计算机的，顶多再算半个学工管的，想着去知道个广义货币Ｍ2是啥，到底有没有用，会用在哪，什么时候能用，一概不知。现在，经历了一些事，看过一些事之后，我的结论是：肯定有用。就跟人读的书一样，当时百分百是没用的，它的用处可能要三年五年十年才看出来，而一旦要看出来了，就是人与人之间差距开始飞速拉开的时候，到那时候一个天上一个地下，回过头来才想着提高，已经比人家落下好长好长的路了。人的一辈子其实很长，尤其对于20来岁的青年，你真的不知道什么时候机会降临在你的头上，努力和不努力的区别之一就是这个机会是给你还是给别人。大多数人都奋斗在底层和中层，有时候一个来自所仰望之处的机会，完全可以决定一个人的命运。 学生时代最大的好处就是时间多，退一万步讲，不管学啥，时间不浪费在游戏，抖音上，就已经超过了百分之五十的人，再坚持往适合自己的，正确的方向不断努力，可以说是已经超过了绝大多数。另外一部分的少数人，不好意思，人家比你有钱有爹妈有背景还比你早知道努力的重要性，这种就慢慢向人家看齐，努力跟人家成为事业上的好朋友吧。再洒一句鸡汤，说的确实好：向上的路从来不拥挤，因为走的人太少。 另外，成长的路上最好还是交一二挚友，既可以和你共同努力，更重要的是可以作为你的一面镜子，修正你不要往偏的方向越走越偏。一个人闷头奋斗，若心智不足够坚定，头脑不足够清晰，可能会很容易走歪的吧。还有，谨慎采取你周围人的建议，大家层次彼此彼此，看问题都是一瓶子水不满半瓶子水晃荡，没多大用的，不如费点心思多跟大佬们交流一下。 最后，圈子对人的影响实在是太大了，他在你年轻的时候决定你会成为一个优秀的人还是废人，在你工作了之后决定你是幸福还是不幸福。所以，努力向一个适合你的圈子奋进吧 Last Edit at: 2018/12/13 haining]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人来人往》]]></title>
    <url>%2Fdiary%2F1104%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-OEqlHRCR"), narrow: false, autoplay: false, showlrc: false, music: { title: "人来人往", author: "陈奕迅", url: "http://www.170hi.com/kw/other.web.rs01.sycdn.kuwo.cn/resource/n2/73/95/1035977425.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 闭起双眼你最挂念谁眼睛张开身边竟是谁感激车站里尚有月台 能让我们满足到流泪拥不拥有也会记住谁快不快乐有天总过去 爱若为了永不失去谁勉强娱乐过谁 谁也会走刚相恋的你先知我们未够借故松开我的手藏在贴纸相背后 我这苦心开过没有但试过散心旅游 如何答没有 闭起双眼你最挂念谁眼睛张开身边竟是谁 拥不拥有也会记住谁快不快乐留在身体里 爱若为了永不失去谁勉强娱乐过谁 爱若难以放进手里何不将这双手放进心里 时间会走究竟什么 是可以拥有 缠在那颈背后最美丽长发未留在我手我也开心饮过酒]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用深度学习找到你想要的代码]]></title>
    <url>%2Fpublic%2FDeepCS%2F</url>
    <content type="text"><![CDATA[这篇文章是对2018年发表在ICSE上的论文《Deep code search》的解析，原文链接在此。 综述论文中，作者利用深度学习技术实现了一种代码搜索工具 DeepCS，其主要特点可总结为如下几个方面： 以往的代码搜索工具，比如CodeHow、Lucene等，基本上都是基于信息检索技术，将代码看做文本文档，通过匹配文本或者代码API的相似性，来找到和自然语言查询所对应的代码片段。 这种方法存在一些问题，比如仅通过关键词这些较为直接和表层的方面来完成一次搜索匹配（当然这种方法也是有效的），没有充分考虑和利用到「自然语言查询语句」和「代码片段」在语义上的关系。文章提出的新的代码搜索方案考虑到了两者的多个关联层面，综合了代码的方法名称、API序列、标记等各个方面，力求在语义上更好地理解代码查询的过程。 提出联合嵌入的思路，将 代码片段 和 自然语言查询语句利用字嵌入或者one-hot表示为统一维度的向量，通过向量的余弦相似度来衡量二者之间的相似性也就是匹配程度。 提出了一种新型的人工神经网络CODEnn(Code Description Embedding Neural Network),COnn用来将一个代码片段映射为向量，DEnn用于将自然语言描述映射为向量，经过给定格式数据元组对CODEnn进行训练之后，该网络可以自动将任一代码片段或者描述映射为向量。 DeepCS使用了两种深度学习的框架进行实现：keras和pytorch，具体环境为: Ubuntu 16.04 Python 2.7-3.6 Keras 2.0 or newer Tensorflow or Theano 0.8.0~0.9.1. 原理论文提出的基于深度学习的代码搜索工具的实现思路如下： 收集训练数据：从github中，结合一定的条件，筛选出符合要求的Java代码片段 离线训练模型：从获得的代码片段中，抽取相关信息，构造训练数据元组。输入模型的是代码和描述两种数据元组，经过RNN以及池化层特征采样，输出两个高维的向量，并进一步通过二者的比较输出余弦相似度，最终得到可用的CODEnn 离线代码嵌入：此处的代码嵌入指的是，对我们要进行搜索的代码库进行嵌入（同样从github中获取，但和训练库相异），也就是经过COnn将代码表示为正确的向量形式，得到一个代码向量库 在线代码搜索：当一次查询到来时，首先经过DEnn将查询表示为向量，然后把这个向量和之前得到的代码向量库作相似度比较，得到想要的代码片段。 论文提出的代码搜索工具的工作方式为：用户在线搜索，输入查询描述语句，后台经过DEnn表示成向量，和使用COnn事先得到的代码向量库作余弦相似度比较，最终返回相似度最大的top K作为查询结果。 效果工具的在线演示demo效果如下图：工具的在线运行demo暂时不可用.. 下面对论文进行详解： 基于信息检索技术的代码搜索（IR-based）工具存在两个问题： 自然语言查询中反映出的高级意图和源代码中的低层次实现细节不匹配 它们两者之间没有共同的词汇标记(lexical tokens)，同义词(synonyms)或者语言结构(language structures)，对于符合搜索条件的代码片段，但是没有在代码中出现相关关键词或者同义词，可能仅仅是语义上的相关（semantically related）时, 这种方法就无能为力了。 不能很好地处理不相关的关键词以及噪声词语（不能很好地理解查询意图） 举个例子，现在有一个查询 &quot;read an object from an xml&quot; ，以下代码片段符合是搜索条件的：1234567891011public static &lt; S &gt; S deserialize(Class c, File xml)&#123; try&#123; JAXBContext context = JAXBContext.newInstance(c); Unmarshaller unmarshaller = context.creatUnmarshaller(); S deserialize = (S) unmarshaller.unmarshal(xml); return deserialized; &#125; catch (JAXBException ex) &#123; log.error("Error-deserializing-object-from-xml", ex); return null; &#125;&#125; 然而，对于上述代码，IR-based 大概率是搜索不出来的，因为代码不包含诸如 read、object之类的关键词，也没有load、instance这样的同义词。因此，一个有效的代码搜索工具需要在代码和自然语言查询之间进行更高级别的映射。 深度学习的方法旨在解决这两个问题。深度学习的优势在于，可以学习查询的语义以及相应的 API 序列，以及去除不相关关键词的影响。在语义层面上，能比现有的方法更好地理解用户需要什么样的代码。 搜索源代码比生成相关API要困难得多，因为代码片段的语义不仅与API序列相关，而且与源代码的其他方面（如标记和方法名称）相关。如：对于&quot;save image as png&quot;以及&quot;save image as jpg&quot;这两个查询，DeepAPI会返回相同的API也就是imageIO.write，然而，根据源代码的相关标记，这两个查询实际的代码片段是不一样的。这也就要求深度学习的模型能够诠释源代码的更多方面。 论文就提出了一种新的模型叫做CODEnn(Code-Description Embedding Neural Network)，目的是把自然语言描述和代码片段嵌入到一个高维度的向量空间中，通过这种方式，二者就有了一个相似的向量表示，可以根据它们的向量来检索与自然语言查询在语义上相关的代码片段，还可以识别语义相关的单词，并且处理查询中的不相关/噪声关键字。 基于这种CODEnn模型，论文实现了一种代码搜索工具DeepCS，DeepCS使用GitHub上的1820万个Java代码片段训练CODEnn模型，然后它从代码库中读取代码片段，并使用经过训练的CODEnn模型将它们嵌入到高维度向量中。最后，当用户查询到达时，DeepCS会找出和查询向量距离最近的代码片段并返回。模型通过50个从Stack Overflow获得的真实查询进行验证，验证显示，查询结果比使用Code-How或者Lucene(两种传统代码搜索工具)的效果好一些。 接下来首先介绍一下相关技术，再阐述工具的设计和实现。 1.嵌入技术（Embedding Techniques）嵌入技术用来学习实体（如单词、句子、图像）的向量表示，使得相似的实体具有相似的向量。例如，execute的表示为[0.12, -0.32, 0.01]，而 run 的向量表示为[0.12, -0.31, 0.02]，从向量上我们可以估计他们的距离，确定他们之间的语义关系。字嵌入通常使用CBOW和Skip-Gram模型，模型构建了一个神经网络，用于捕捉单词及其上下文单词之间的关系，单词的向量表示作为神经网络的参数，并用文本语料库进行训练。 2.用于序列嵌入的递归神经网络（Recurrent Neural Networks）递归神经网络（RNN）是两种人工神经网络的总称。一种是时间递归神经网络（recurrent neural network），又名循环神经网络，另一种是结构递归神经网络（recursive neural network）。时间递归神经网络代表信息在时间维度从前往后的的传递和累积，在神经网络结构上表现为：前面的NN的隐藏层的输出作为后面的NN的隐藏层的输入。而结构递归神经网络是在空间维度上的展开。利用相似的神经网络结构递归构造更为复杂的深度网络。RNN一般指代时间递归神经网络。在此只作一下简单的介绍，关于二者的具体区别可以参考一下这个quora上的回答。以下的RNN统一指的是循环神经网络。在此对于RNN的基础理论不作过多介绍，如果你不知道RNN是什么，需要先了解一下有关RNN的基本理论知识。 我们可以利用RNN，对自然语句这样的序列数据进行嵌入，RNN的基本结构如图a所示。神经网络包括三层，输入层将每个输入映射为向量，循环隐藏层在读取每个输入之后循环计算和更新隐藏状态，输出层把隐藏状态应用于特定的任务。与传统的前馈神经网络不同，RNN可以利用其内部的存储嵌入一些顺序输入，比如句子。图b就是将句子嵌入到一个向量中的例子，通常来说也是图a的展开形式。 综上，我们把一段序列数据定义为多个单词的集合：s=w1, …,wT，然后通过如下过程将序列表示为向量。 从序列中逐个读入单词 wt, 每读入一个单词，更新隐藏层状态 ht 每个单词 wt，都通过one-hot表示或者字嵌入技术，被映射为一个d维的向量，每次 ht 的更新都是根据当前单词的输入 wt 和 ht-1 完成的。 整个过程完成后，得到一系列的隐藏层状态 h* ,一般来说，取最后的状态 ht 作为句子的向量表示，也可以将所有隐藏层状态矩阵作 max-pooling 得到最终向量表示。图示如下： 3. 联合嵌入(Joint embedding)自然语言描述和代码片段,两种数据的构成是不同的，所以无法简单的通过文本流匹配到一起（之前的方法把代码看做文本，仅通过关键词匹配等直接的手段，可以视为二者是同构的）。要想考虑代码片段的多方面因素（前文提到的API、tokens等），需要以一种新的方式去看待代码和自然语言查询。于是，联合嵌入应运而生，联合嵌入将二者嵌入到同一个向量空间中去，换算成统一的、向量形式的表示，这样，代码片段的各方面特征便不会丢失。 明确了相关技术之后，下一步就是设计一种用于代码搜索的深度神经网络。 CODEnn结构设计(Code Description Embedding Neural Network)CODEnn结构如下图所示： 该网络由两部分构成,COnn(code embedding network)将代码表示为向量,DEnn(description embedding network)把自然语言描述表示为向量。代码和描述分别经过RNN处理、maxpooling采样之后，得到最终向量，然后进行相似度比较。 训练集在训练之前，首先要对训练数据进行预处理。 数据收集： 训练数据来自github上开源项目中有文档注释的Java方法（/* 和 /之间的部分），如果该代码片段符合Java编程规范，那么文档注释的第一句是可以用来作该代码片段的自然语言描述的。且可以提取方法的有关声明作为代码元素。 最终，去掉0个star的和没有文档说明的一部分，得到 1823.3872 万的Java代码片段作为训练语料库。 抽取数据元组：&lt; method name, API sequence, tokens, description&gt; method name：利用驼峰命名法则的特点把 函数名 解析成一系列的标记（a sequence of tokens），listFiles –&gt; list, Files API sequence：使用Eclipse JDT编译器解析和遍历AST，有着一系列的规则和过程，比如，new C()，API序列就是 C.new tokens：从方法中，还是根据驼峰命名，分割出token，然后去掉休止词the，in这些，还有去掉源码中的Java关键词 description：使用Eclipse JDT编译器解析AST，从AST中抽取JavaDoc 下图是抽取的数据元组示例： 训练和评估训练：DeepCS的工作流是：离线训练模型，离线代码和描述嵌入，在线代码搜索，如图： 训练过程输入：&lt; C, D+, D-&gt; 训练模型输出：余弦相似度 输入元组均为向量表示,其中 D+ 为正确描述，D- 为错误表示，注意：D+和D-均来自训练数据。 评估：构造验证集：从github中选择至少获得20个star的、不在语料库之中的Java项目，包括没有JavaDoc的代码片段（训练集的代码片段包含自然语言描述）。最终共获得了 1626.2602 万个方法，对于每个方法，均抽取&lt; method name, API sequence, tokens&gt;，以此生成代码向量。 选择查询问题：从stackoverflow中Java编程问题的标签中选top 50并排序，找出其中有具体代码片段的回答。 性能评估：采用四种量化标准–FRank, SuccessRate@k, Precision@k,Mean Reciprocal Rank (MRR) FRank 指第一个匹配到的结果在查询结果列表中的排名数，越小代表越好。 工具之间的比较：Lucene、CodeHow—FRank值DeepCS为3.5，CH为5.5，Lucene为6.0. 不足之处DeepCS考虑到了查询的语义层面，不仅仅是关键词的匹配，这带来了性能上的很大提升，但是DeepCS也会出现查询到不相关的结果的情况，这很大程度上是因为，考虑到的影响查询结果的因素不够全面，如果把更多的代码层面的特征纳入代码向量中，比如程序的上下文，可以让工具变得更为可用。 除此之外，在评估阶段，是由两名开发者手工比对查询结果以及从stackoverflow筛选正确的匹配，不可避免地出现有分歧的情况，虽然通过多次的讨论解决了这种分歧，后续让更多的开发者参与评估会一定程度上提升结果的准确性。 另外，结果只是从stackoverflow进行评估，具有一定的片面性，后期会加入更多的权威搜索引擎及网站，达到更好的效果。 last edit at 2018/08/22 by haining]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法的基本示例]]></title>
    <url>%2Fpublic%2Fmarkdown-demo%2F</url>
    <content type="text"><![CDATA[本文是对如何在 Hexo 下的 NexT 主题中写 Markdown 文件的介绍，其中大部分是 Markdown 的基础语法，还有一些是 NexT 主题自带的特性。 在此查看和下载 markdown-demo.md源文件 正文参考如下，采用 代码 + 效果 的方式展示：1234567Text can be **bold**, _italic_, or ~~strikethrough~~.[Link to another page](./another-page.html).There should be whitespace between paragraphs.There should be whitespace between paragraphs. We recommend including a README... Text can be bold, italic, or strikethrough. Link to another page. There should be whitespace between paragraphs. There should be whitespace between paragraphs. We recommend including a README… 123456789101112131415161718# Header 1This is a normal paragraph following a header. ## Header 2&gt; This is a blockquote following a header.&gt;&gt; When something is important enough, you do it even if the odds are not in your favor.### Header 3```js// Javascript code with syntax highlighting.var fun = function lang(l) &#123; dateformat.i18n = require(&apos;./lang/&apos; + l) return true;&#125; Header 1This is a normal paragraph following a header. Header 2 This is a blockquote following a header. When something is important enough, you do it even if the odds are not in your favor. Header 312345// Javascript code with syntax highlighting.var fun = function lang(l) &#123; dateformat.i18n = require('./lang/' + l) return true;&#125; 1234# Ruby code with syntax highlightingGitHubPages::Dependencies.gems.each do |gem, version| s.add_dependency(gem, "= #&#123;version&#125;")end 12345678910111213141516171819202122232425#### Header 4* This is an unordered list following a header.* This is an unordered list following a header.* This is an unordered list following a header.##### Header 51. This is an ordered list following a header.2. This is an ordered list following a header.3. This is an ordered list following a header.###### Header 6| head1 | head two | three ||:-------------|:------------------|:------|| ok | good swedish fish | nice || out of stock | good and plenty | nice || ok | good `oreos` | hmm || ok | good `zoute` drop | yumm |### There&apos;s a horizontal rule below this.* * * Header 4 This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header. Header 5 This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header. Header 6 head1 head two three ok good swedish fish nice out of stock good and plenty nice ok good oreos hmm ok good zoute drop yumm There’s a horizontal rule below this. 123456789101112131415161718192021222324252627282930313233343536373839### Here is an unordered list:* Item foo* Item bar* Item baz* Item zip### And an ordered list:1. Item one1. Item two1. Item three1. Item four### And a nested list:#### 不同 level 之间是两个空格- level 1 item - level 2 item - level 2 item - level 3 item - level 3 item- level 1 item - level 2 item - level 2 item - level 2 item- level 1 item - level 2 item - level 2 item- level 1 item### Small image![Octocat](https://assets-cdn.github.com/images/icons/emoji/octocat.png)### Large image![Branching](https://guides.github.com/activities/hello-world/branching.png) Here is an unordered list: Item foo Item bar Item baz Item zip And an ordered list: Item one Item two Item three Item four And a nested list:不同 level 之间是两个空格 level 1 item level 2 item level 2 item level 3 item level 3 item level 1 item level 2 item level 2 item level 2 item level 1 item level 2 item level 2 item level 1 item Small image Large image 1234567891011121314151617181920### Definition lists can be used with HTML syntax.&lt;dl&gt;&lt;dt&gt;Name&lt;/dt&gt;&lt;dd&gt;Godzilla&lt;/dd&gt;&lt;dt&gt;Born&lt;/dt&gt;&lt;dd&gt;1952&lt;/dd&gt;&lt;dt&gt;Birthplace&lt;/dt&gt;&lt;dd&gt;Japan&lt;/dd&gt;&lt;dt&gt;Color&lt;/dt&gt;&lt;dd&gt;Green&lt;/dd&gt;&lt;/dl&gt;`` `Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.`` ``` `The final element.`` ` Definition lists can be used with HTML syntax.NameGodzillaBorn1952BirthplaceJapanColorGreen 1Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. 1The final element. 以上就是 Markdown 基本语法，除此之外，NexT 主题自带了一些效果。插入一段音频：12 update at: 2018/07/12]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo备忘录]]></title>
    <url>%2Fpublic%2FHexo_memo%2F</url>
    <content type="text"><![CDATA[Hexo基本指令这是我的博客的第一篇文章，以后会多在这里分享一些我的成长和感悟。 在当前文件夹建立并初始化一个网站1hexo init layout为页面布局，默认是在_config.yml文件里设置的布局，此命令新建一篇文章1hexo new [layout] &quot;title&quot; 清除数据库和 public 也就是准备发布到服务器上的文件夹1hexo clean 生成网站静态文件1hexo g 发表为草稿1hexo publish &quot;title&quot; 部署到本地服务器，打开http://localhost:4000/即可查看1hexo s 部署到 usrname.github.io，也就是你的github上。1hexo d 运行此命令需要事先安装 hexo-deployer-git ，在命令行输入如下命令： 1npm install hexo-deployer-git --save 安装完成之后，在_config,yml中配置deploy：123deploy: type: git repo: your github address 更多设置参见Hexo指令Last Edit : 2018.07.11]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
</search>

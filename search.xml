<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用深度学习找到你想要的代码]]></title>
    <url>%2Fpublic%2FDeepCS%2F</url>
    <content type="text"><![CDATA[基于信息检索技术的代码搜索（IR-based）工具存在的问题： 自然语言查询中反映出的高级意图 和 源代码中的低层次实现细节 不匹配 它们两者之间没有共同的词汇标记(lexical tokens)，同义词(synonyms)或者语言结构(language structures)，对于符合搜索条件的代码片段，但是没有在代码中出现相关关键词或者同义词，可能仅仅是语义上的相关（semantically related）时, 这种方法就无能为力了。 不能很好地处理不相关的关键词以及噪声词语（不能很好地理解查询意图） 举个例子，现在有一个查询*&quot;read an object from an xml&quot;*，以下代码片段符合是搜索条件的：1234567891011public static &lt; S &gt; S deserialize(Class c, File xml)&#123; try&#123; JAXBContext context = JAXBContext.newInstance(c); Unmarshaller unmarshaller = context.creatUnmarshaller(); S deserialize = (S) unmarshaller.unmarshal(xml); return deserialized; &#125; catch (JAXBException ex) &#123; log.error("Error-deserializing-object-from-xml", ex); return null; &#125;&#125; 然而，对于上述代码，IR-based 大概率是搜索不出来的，因为代码不包含诸如 read、object之类的关键词，也没有load、instance这样的同义词。因此，一个有效的代码搜索工具需要在代码和自然语言查询之间进行更高级别的映射。 深度学习的方法旨在解决这两个问题。深度学习的优势在于，可以学习查询的语义以及相应的 API 序列，以及去除不相关关键词的影响。 搜索源代码比生成相关API要困难得多，因为代码片段的语义不仅与API序列相关，而且与源代码的其他方面（如标记和方法名称）相关。如：对于*&quot;save image as png&quot;*以及*&quot;save image as jpg&quot;*这两个查询，DeepAPI会返回相同的API也就是imageIO.write，然而，根据源代码的相关标记，这两个查询实际的代码片段是不一样的。这也就要求深度学习的模型能够诠释源代码的更多方面。 论文就提出了一种新的模型叫做CODEnn(Code-Description Embedding Neural Network)，目的是把自然语言描述和代码片段嵌入到一个高维度的向量空间中，通过这种方式，二者就有了一个相似的向量表示，可以根据它们的向量来检索与自然语言查询在语义上相关的代码片段，还可以识别语义相关的单词，并且处理查询中的不相关/噪声关键字 基于这种CODEnn模型，论文实现了一种代码搜索工具DeepCS，DeepCS使用GitHub上的1820万个Java代码片段训练CODEnn模型，然后它从代码库中读取代码片段，并使用经过训练的CODEnn模型将它们嵌入到高维度向量中。最后，当用户查询到达时，DeepCS会找出和查询向量距离最近的代码片段并返回。模型通过50个从Stack Overflow获得的真实查询进行验证，验证显示，查询结果比使用Code-How和基于Lucene(两种传统代码搜索工具)的表现要好。 接下来首先介绍一下相关技术，再阐述工具的设计和实现。 1.嵌入技术（Embedding Techniques）嵌入技术用来学习实体（如单词、句子、图像）的向量表示，使得相似的实体具有相似的向量。例如，execute的表示为[0.12,-0.32,0.01]，而 run 的向量表示为[0.12,-0.31,0.02]，从向量上我们可以估计他们的距离，确定他们之间的语义关系。字嵌入通常使用CBOW和Skip-Gram模型，模型构建了一个神经网络，用于捕捉单词及其上下文单词之间的关系，单词的向量表示作为神经网络的参数，并用文本语料库进行训练。 2.用于序列嵌入的递归神经网络（Recurrent Neural Networks）递归神经网络（RNN）是两种人工神经网络的总称。一种是时间递归神经网络（recurrent neural network），又名循环神经网络，另一种是结构递归神经网络（recursive neural network）。时间递归神经网络代表信息在时间维度从前往后的的传递和累积，在神经网络结构上表现为后面的NN的隐藏层的输入是前面的NN的隐藏层的输出。而结构递归神经网络是在空间维度上的展开。利用相似的神经网络结构递归构造更为复杂的深度网络。RNN一般指代时间递归神经网络。在此只作一下简单的介绍，关于二者的具体区别可以参考一下这个quora上的回答。以下的RNN统一指的是循环神经网络。在此对于RNN的基础理论不作过多介绍，如果你不知道RNN是什么，可以自己Google或者百度学习一下，在这推荐一篇文章，这篇文章举的例子比较多，原理上也比较易懂。 我们可以利用RNN，对自然语句这样的序列数据进行嵌入，RNN的基本结构如图a所示。神经网络包括三层，输入层将每个输入映射为向量，循环隐藏层在读取每个输入之后循环计算和更新隐藏状态，输出层把隐藏状态应用于特定的任务。与传统的前馈神经网络不同，RNN可以利用其内部的存储嵌入一些顺序输入，比如句子。图b就是将句子嵌入到一个向量中的例子，通常来说也是图a的展开形式。]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法的基本示例]]></title>
    <url>%2Fpublic%2Fmarkdown-demo%2F</url>
    <content type="text"><![CDATA[本文是对如何在 Hexo 下的 NexT 主题中写 Markdown 文件的介绍，其中大部分是 Markdown 的基础语法，还有一些是 NexT 主题自带的特性。 在此查看和下载 markdown-demo.md源文件 正文参考如下，采用 代码 + 效果 的方式展示：1234567Text can be **bold**, _italic_, or ~~strikethrough~~.[Link to another page](./another-page.html).There should be whitespace between paragraphs.There should be whitespace between paragraphs. We recommend including a README... Text can be bold, italic, or strikethrough. Link to another page. There should be whitespace between paragraphs. There should be whitespace between paragraphs. We recommend including a README… 123456789101112131415161718# Header 1This is a normal paragraph following a header. ## Header 2&gt; This is a blockquote following a header.&gt;&gt; When something is important enough, you do it even if the odds are not in your favor.### Header 3```js// Javascript code with syntax highlighting.var fun = function lang(l) &#123; dateformat.i18n = require(&apos;./lang/&apos; + l) return true;&#125; Header 1This is a normal paragraph following a header. Header 2 This is a blockquote following a header. When something is important enough, you do it even if the odds are not in your favor. Header 312345// Javascript code with syntax highlighting.var fun = function lang(l) &#123; dateformat.i18n = require('./lang/' + l) return true;&#125; 1234# Ruby code with syntax highlightingGitHubPages::Dependencies.gems.each do |gem, version| s.add_dependency(gem, "= #&#123;version&#125;")end 12345678910111213141516171819202122232425#### Header 4* This is an unordered list following a header.* This is an unordered list following a header.* This is an unordered list following a header.##### Header 51. This is an ordered list following a header.2. This is an ordered list following a header.3. This is an ordered list following a header.###### Header 6| head1 | head two | three ||:-------------|:------------------|:------|| ok | good swedish fish | nice || out of stock | good and plenty | nice || ok | good `oreos` | hmm || ok | good `zoute` drop | yumm |### There&apos;s a horizontal rule below this.* * * Header 4 This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header. Header 5 This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header. Header 6 head1 head two three ok good swedish fish nice out of stock good and plenty nice ok good oreos hmm ok good zoute drop yumm There’s a horizontal rule below this. 123456789101112131415161718192021222324252627282930313233343536373839### Here is an unordered list:* Item foo* Item bar* Item baz* Item zip### And an ordered list:1. Item one1. Item two1. Item three1. Item four### And a nested list:#### 不同 level 之间是两个空格- level 1 item - level 2 item - level 2 item - level 3 item - level 3 item- level 1 item - level 2 item - level 2 item - level 2 item- level 1 item - level 2 item - level 2 item- level 1 item### Small image![Octocat](https://assets-cdn.github.com/images/icons/emoji/octocat.png)### Large image![Branching](https://guides.github.com/activities/hello-world/branching.png) Here is an unordered list: Item foo Item bar Item baz Item zip And an ordered list: Item one Item two Item three Item four And a nested list:不同 level 之间是两个空格 level 1 item level 2 item level 2 item level 3 item level 3 item level 1 item level 2 item level 2 item level 2 item level 1 item level 2 item level 2 item level 1 item Small image Large image 1234567891011121314151617181920### Definition lists can be used with HTML syntax.&lt;dl&gt;&lt;dt&gt;Name&lt;/dt&gt;&lt;dd&gt;Godzilla&lt;/dd&gt;&lt;dt&gt;Born&lt;/dt&gt;&lt;dd&gt;1952&lt;/dd&gt;&lt;dt&gt;Birthplace&lt;/dt&gt;&lt;dd&gt;Japan&lt;/dd&gt;&lt;dt&gt;Color&lt;/dt&gt;&lt;dd&gt;Green&lt;/dd&gt;&lt;/dl&gt;`` `Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.`` ``` `The final element.`` ` Definition lists can be used with HTML syntax.NameGodzillaBorn1952BirthplaceJapanColorGreen 1Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. 1The final element. 以上就是 Markdown 基本语法，除此之外，NexT 主题自带了一些效果。插入一段音频：12 update at: 2018/07/12]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo备忘录]]></title>
    <url>%2Fpublic%2FHexo_memo%2F</url>
    <content type="text"><![CDATA[Hexo基本指令这是我的博客的第一篇文章，以后会多在这里分享一些我的成长和感悟。 在当前文件夹建立并初始化一个网站1hexo init layout为页面布局，默认是在_config.yml文件里设置的布局，此命令新建一篇文章1hexo new [layout] &quot;title&quot; 清除数据库和 public 也就是准备发布到服务器上的文件夹1hexo clean 生成网站静态文件1hexo g 发表为草稿1hexo publish &quot;title&quot; 部署到本地服务器，打开http://localhost:4000/即可查看1hexo s 部署到 usrname.github.io，也就是你的github上。1hexo d 运行此命令需要事先安装 hexo-deployer-git ，在命令行输入如下命令： 1npm install hexo-deployer-git --save 安装完成之后，在_config,yml中配置deploy：123deploy: type: git repo: your github address 更多设置参见Hexo指令Last Edit : 2018.07.11]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
</search>

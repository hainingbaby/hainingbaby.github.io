<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <url>%2Fpublic%2Fleetcode%2F</url>
    <content type="text"><![CDATA[leetcode题目，持续更新 448. Find All Numbers Disappeared in an Array. Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input:[4,3,2,7,8,2,3,1] Output:[5,6] 解：在一个整数数组中找出所有未出现过的数并输出，要求时间复杂度O(n),而且不浪费额外的空间。正常的思路是两个循环解决问题。空间上不多余，但时间复杂度是0(n^2)。考虑到是一个整数数组，可以利用索引与本身数值的关系。 如果这个数组是顺序排列的那就好了，我只需要判断索引 i 的值是不是 i+1（num[i] == i+1)，就能知道这个数在不在数组里。然后得出结果就行了。 问题的关键就在于，数组不是顺序排列的，这个简单的判断方法不好使了，之前是按照索引找数值，因为本题情况的特殊化，可不可以按照数值找索引呢？ 也就是说，一个整数数组[4,3,2,7,8,2,3,1]，有 4 这个数值，就意味着，在顺序排列的数组里，num[3]是可以映射到4的（num[3]==4），有 3 这个数值，那么num[2]可以映射到3（num[2]==3），有 num[i]这个数值，那么 num[ num[i]-1 ] 可以映射到num[i]。所以，是不是遍历一次这个数组，如果有个整数不在这个数组里边，那么我们就无法对他作出处理，使其在顺序数组里索引和数值相对应？ 所以，思路有了： 遍历一遍数组，对于每一个整数num[i]，把这个整数，在假设的顺序排列数组里的索引，也就是「num[i]-1」（注意，这是一个索引）做上标记，目的是和没有出现在数组里的整数的索引区分开来。 再遍历一遍（这个数组或者你自己新建的数组，后边会解释），根据标记，返回最终结果。 怎么做标记区分开出现的和没出现的整数？举两个例子。 新建一个数组a，初始化为1，见到第一个数4，把a[3]改为0，见到3，把a[2]改为0，见到2把a[1]改为0，依次继续。突然，见到了第二个2出现了，这时候改不改都无所谓，因为a[2]已经是0了。注意，这个地方的数字本来应该是缺少的那一个，也就是我们寻找的结果，是几呢，5，所以他本来应该把a[4]改成0，但是现在没有改。所以，再遍历一次你新建的a数组，哪个索引 i 对应的数值是 1 ，则 i+1 就是我们要找的那个未出现在数组里的整数（因为我们利用了顺序数组的性质进行的改值操作）。 方法1自己开辟了一个数组a，能不能在原数组上改呢？能，改成原来值的负值是一个不错的选择，虽然我们根本不关心它的值为负还是为0，只是需要区分在其中的整数和不在其中的整数的区别罢了。但是在把当前数值转换成索引的时候会变动后边的数值，取负值可以用绝对值函数abs，不影响后边的变换。改成0就不行了。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; for(int i = 0 ; i &lt; nums.size(); i++)&#123; int index = abs(nums[i])-1; if(nums[index]&gt;0) nums[index] = -nums[index]; &#125; for(int j=0; j&lt; nums.size(); j++)&#123; if(nums[j] &gt; 0) res.push_back(j+1); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Github中Fork了一个仓库，如何在这个仓库变化之后，仍然保持代码一致]]></title>
    <url>%2Fpublic%2Fgithub-mem%2F</url>
    <content type="text"><![CDATA[github操作备忘 0X01.假设要Fork的别人的repo为 A ，Fork到你的github之后叫做 a ，现在别人对 A 进行了更新，和 a 不一致了。如何保持一致？ 克隆 a 到本地 1git clone a的github地址 在本地添加最新的 A 为一个分支 1git remote add upstram [原项目地址] 其中upstream是自己任起的分支名字，一般用这个表示最上游分支。 fetch 这个最新的 A 到本地 1git fetch upstream 接下来要merge两个分支，先确保你现在已经处于要merge到的master分支下边(或者不是master是你自己的分支) 1git checkout master merge 1git merge upstream/master 推送到自己的github仓库 1git push origin master 结束。 0X02.在本地修改之后如何撤销？ 方法1：123git checkout . #撤销对所有已修改但未提交的文件的修改，但不包括新增的文件git checkout [filename] #撤销对指定文件的修改 方法二：1git reset --hard [commit id] #commit id 通过 git log查看]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正月里来是新年呦]]></title>
    <url>%2Fdiary%2F2019-02-25%2F</url>
    <content type="text"><![CDATA[哈 哈 哈 哈 哈 印象很深刻的一次过年。 四个兄弟在一起吃鸡开黑吹牛逼，一晚上笑的比我整个2018年加起来都多，笑到脸抽筋，嗓子都哑了，舒服！ 三个傻逼喝了一晚上的酒，都醉醺醺了，找了个没人住的房子，互相约定不准睡觉，谁先睡着就扇他耳光，三个人大眼瞪小眼，熬不住了就在房间里瞎走，愣是一晚上都没睡觉，美名其曰: 熬鹰。牛逼！ 两个二货互相打配合逃离亲戚，各种疯狂各种嗨；为了一块钱斡旋一下午，各种套路与反套路，也是一种很让人怀念的庸俗趣味！ 还有各种不可描述的事，说都不好意思说出来，真的是从小玩到大的交情才有这些二比的日常，每每回想起来都觉得自己很幸运有这帮兄弟。 这几天经常听到的一句话就是年味越来越淡了，可能是因为我们的生活越来越好了，已经不是以前短吃少喝的年代了，希望我们的生活能越来越好，趣味也一样能越来越多。 18年对我而言是很深刻的一年，前半年是我这么多年来最快乐的，后半年是我这么多年来最痛苦的。刚好就这么碰在一起了，真是嘲讽。整个18年，我很多时候都是被内心感受支配的，我觉得不是很OK。 这一年恰逢风云变幻，我感受最深的就是自己被潮流所推动，随着浪潮起起伏伏，无力感和自己一点点的英雄主义常常撞在一起，让我受其所累，增添了这一年里很多不快乐。 新的一年，就希望自己迎难而上吧。就两个字: 盘它。 2019/02/06 haining]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我研究了一下怎么活的更久一点]]></title>
    <url>%2Fdiary%2Flivelong%2F</url>
    <content type="text"><![CDATA[这是一则小科普文。 写文章真是一件不容易的事，每次信誓旦旦的下笔，结果每次写完之后都感觉离预期有多远差多远…以前还自我感觉不错，真正写起来才发现不是那么一回事，眼高手低，尴尬。 不过还是决定要开始写并继续写下去了。不怕，谁还没个过程不是，19年我要坚持写下去，倒逼我不断学习，希望一年之后回过头来看，我能进步很多。 今天想分享的是关于人的寿命的话题，偶然间看到一个演讲说的是「如何延缓衰老」，我觉得还挺有意思，去查了很多的资料，最终整合了一下并得出了一些可靠性较高的结论，不敢保证全面，但是不会瞎说，有兴趣的可以继续看下去。 参考的资料主要包括一些中科院的公开演讲，以及一些生物科学团队的研究，还有像裴端卿这样的德高望重有分量的领域内KOL的言论，裴端卿上过开讲了这个节目，我个人一直很喜欢他，不哗众取宠，是潜心研究干实事的那种，而且在生物科学界很有话语权。另外我还翻了几篇国外的论文，不过我水平有限，且文章学术性太高，没有太多实质性的发现。至于百度，没有打开过，毕竟即使不能长命百岁，我也希望最起码不要少活几年…说实话，我是很想活久一点的，毕竟现在的世界变化这么快，一百年后将会变成什么样子，是一件很让人激动和期待的事情，能够亲自见证这一切的变化会是一件多么excited的事啊！所以我也在很认真地得出一些靠谱的结论，然后把自己当成小白鼠来上这么一次实验… 先啰嗦几句区别，「延缓衰老」和「延长寿命」其实是两件不同的事。比如说，延缓衰老是指一个人100岁的时候像80岁，但是实现了延缓衰老并不意味着人就一定能活到100岁，也可能它在80岁的时候，就带着看起来像60岁的样子嗝屁了。而且嗝屁的原因就是两者的区别所在，我从两个原因说明一下： 1.疾病、意外等不可控因素。这是属于人没办法自己控制的，假设某天一个人出了车祸，或者被查出癌症晚期，再怎么延缓衰老，看起来年轻，它的生命可能都要即将到尽头了。这种情况下，延长寿命成了妄谈，但是延缓衰老的效果，是这个人在此之前的每一天的生活里都可以享受到的。面对疾病，专家学者们也在寻找很多治疗疾病延长寿命的办法，像癌症疫苗，基因编辑等等技术，领域发展不断取得突破，我们欢欣鼓舞，但是目前情况下更实惠的当属「延缓衰老」。 2.排除癌症等意外，正常情况下，延缓衰老有很多方式，但并非每一种都能延长寿命，比如很多爱美的小姑娘希望坚持美丽的小脸蛋30年不动摇，但是过分注重了面部皮肤，往往忽略了身体机能的维持，细胞的再生能力，心率，新陈代谢速率等等指标，其实都应该是「延缓衰老」该考虑的因素，真正的保持年轻应该是内外兼修，正确的延缓衰老才能延长寿命。 所以，下边的结论用于如何更好的延缓衰老，从而延长寿命。结论可信度大概在百分之80到90。另外，其实现在几乎所有的药物以及结论，都尚处于理论研究阶段，是从小猫小狗小鼠小虫身上得出来的，用于人身上的很少，从人身上得出的结论更少，欢迎补充。 低热量饮食这是最靠谱的一种，对每天摄入体内的热量进行限制可以让人更年轻，更有活力，人体各项指标大概率会达到同龄人中较高水平。很久之前就听到这种说法，今天系统地查了一下原理，比较有说服力的一种是：限制性的饮食可以抑制体内一种叫做mTOR分子蛋白的作用，这种蛋白影响转录和蛋白质合成，调节细胞的生长、凋亡、自噬等过程，它的激活和表达失调与癌症，糖尿病等众多疾病的形成有密切的关系，而且「mTOR抑制剂」现在是治疗癌症的一种手段。一些论文研究表示，「mTOR信号通路在卡路里限制饮食所导致的寿命延长和细胞自噬反应过程中能够发挥作用」[1][2][3]。所以，限制饮食的方法不仅可以延缓衰老，还能起到mTOR抑制剂的效果，减少疾病发生的概率，可以算的上是我最中意的养生方式了…低热量饮食在别的动物身上进行的实验效果是可以延长50%的寿命，50%啊，不敢继续想象了～ 总结：限制饮食主要指限制每天摄入体内的热量，至于量的多少因人而异，一般达到吃饱的感觉下的70%-80%的程度就行了，当然更好的方式是仔细分析每种食物含有的热量，然后列出计划合理膳食。饥饿感肯定是会有的，所以毅力也是必须的，即使这样做不能达到效果，天天吃的太饱对身体是一定没有好处的。另外有个不完全靠谱的观点表示：限制饮食开始的年龄阶段越早越有效果，但是不管什么时候开始都是有效的。 运动运动不必多说，这个肯定是必须的。不运动的人到了30多岁之后会废的很快，明显的感觉到身体一天不如一天，连被掏空都不必了，自然空。嘿嘿的时候心有余而力不足，宝宝心里一定特别苦。 但是运动也有误区，一是一定要避免过量运动，在我看来像每天坚持跑步就有点过量了，多少都会对膝盖等关节造成损伤，还有健身房疯狂练肌肉的老哥们，深蹲等姿势不规范都会造成关节和肌肉的损伤，这种损伤年轻的时候没感觉，过上个十年二十年，什么病痛都找上门来了，而且运动过量让体内新陈代谢长期都维持在一个较高水平，这其实是不利于身体的可持续发展的（这个观点具有争议）。所以很多特种兵其实退伍之后身体强盛的状态维持不了太多年，不注重修复的话会老的很快。 总结：运动是必须的，但是要合理适量，而且运动尽量全面，30岁的腿，50岁的腰，老年痴呆的脑子，想想也挺尴尬的。我个人比较喜欢的运动方式是走路，打球，健身的话以后要多练腰臀腿还有核心，偶尔跑跑步，以后有机会要经常去游泳，就这些。 人际关系人际关系还是挺重要的，国内外早些年就做过关于人际关系对人寿命的影响，发现长寿的人都有一个共同的特点就是人际关系良好，或者说在社会环境中处于一个比较舒适自在的状态，人毕竟是在社会上混的，天天心里堵得慌自然活不好。我认为这个问题的关键在于人要找到自己乐趣所在，这样不管有没有好朋友，才会每天过得开心心心，自然少得病，活得久。不过在现在这个社会的框架上谈朋友的命题好像有点奢侈，但是寻找自己内心的幸福感和舒适感的途径有很多种，这里只是提供一种思路罢了。 总结：好好活着。 其他以上是对我比较有启发的，而且是可信度比较高的，除此之外，其实还有一些观点，相对来说比较可信，比如12年有一篇发在Cell Metabolism杂志上的论文表明白藜芦醇这种物质可以增加干细胞数量[4]，延缓衰老。相关的研究还有很多，其中有一些是真的，也有些是关于白藜芦醇学术作假的。 总结：白藜芦醇有延缓衰老功能，还对预防老年痴呆、白血病这些有一定作用。但是功效不稳定，有副作用，比如减缓机体的凝血机制，就是会让你身体的止血功能下降。含白藜芦醇比较多的是葡萄皮和红酒，所以，我决定以后吃葡萄少吐葡萄皮，平时没事偶尔也可以来点红酒，毕竟不管活多久生活情调还是要提高的嘛～ 不过酒不要多喝，喝多伤肝，还伤心。 水平有限，欢迎指正。 部分论文、资料：[1] mTOR信号通路与衰老及衰老相关重大疾病, http://www.pibb.ac.cn/pibbcn/ch/reader/download_pdf.aspx?file_no=20140007&amp;year_id=2014&amp;quarter_id=3&amp;falg=1 [2] mTOR信号通路与衰老相关疾病, http://www.life.ac.cn/news/upload/20150428-206-213%20142.pdf [3] 揭开mTOR神秘面纱, https://zhuanlan.zhihu.com/p/37438093 [4] Resveratrol rescues SIRT1-dependent adult stem cell decline and alleviates progeroid features in laminopathy-based progeria. https://www.ncbi.nlm.nih.gov/pubmed/23217256]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用深度学习找到你想要的代码]]></title>
    <url>%2Fpublic%2FDeepCS%2F</url>
    <content type="text"><![CDATA[这篇文章是对2018年发表在ICSE上的论文《Deep code search》的解析，原文链接在此。 综述论文中，作者利用深度学习技术实现了一种代码搜索工具 DeepCS，其主要特点可总结为如下几个方面： 以往的代码搜索工具，比如CodeHow、Lucene等，基本上都是基于信息检索技术，将代码看做文本文档，通过匹配文本或者代码API的相似性，来找到和自然语言查询所对应的代码片段。 这种方法存在一些问题，比如仅通过关键词这些较为直接和表层的方面来完成一次搜索匹配（当然这种方法也是有效的），没有充分考虑和利用到「自然语言查询语句」和「代码片段」在语义上的关系。文章提出的新的代码搜索方案考虑到了两者的多个关联层面，综合了代码的方法名称、API序列、标记等各个方面，力求在语义上更好地理解代码查询的过程。 提出联合嵌入的思路，将 代码片段 和 自然语言查询语句利用字嵌入或者one-hot表示为统一维度的向量，通过向量的余弦相似度来衡量二者之间的相似性也就是匹配程度。 提出了一种新型的人工神经网络CODEnn(Code Description Embedding Neural Network),COnn用来将一个代码片段映射为向量，DEnn用于将自然语言描述映射为向量，经过给定格式数据元组对CODEnn进行训练之后，该网络可以自动将任一代码片段或者描述映射为向量。 DeepCS使用了两种深度学习的框架进行实现：keras和pytorch，具体环境为: Ubuntu 16.04 Python 2.7-3.6 Keras 2.0 or newer Tensorflow or Theano 0.8.0~0.9.1. 原理论文提出的基于深度学习的代码搜索工具的实现思路如下： 收集训练数据：从github中，结合一定的条件，筛选出符合要求的Java代码片段 离线训练模型：从获得的代码片段中，抽取相关信息，构造训练数据元组。输入模型的是代码和描述两种数据元组，经过RNN以及池化层特征采样，输出两个高维的向量，并进一步通过二者的比较输出余弦相似度，最终得到可用的CODEnn 离线代码嵌入：此处的代码嵌入指的是，对我们要进行搜索的代码库进行嵌入（同样从github中获取，但和训练库相异），也就是经过COnn将代码表示为正确的向量形式，得到一个代码向量库 在线代码搜索：当一次查询到来时，首先经过DEnn将查询表示为向量，然后把这个向量和之前得到的代码向量库作相似度比较，得到想要的代码片段。 论文提出的代码搜索工具的工作方式为：用户在线搜索，输入查询描述语句，后台经过DEnn表示成向量，和使用COnn事先得到的代码向量库作余弦相似度比较，最终返回相似度最大的top K作为查询结果。 效果工具的在线演示demo效果如下图：工具的在线运行demo暂时不可用.. 下面对论文进行详解： 基于信息检索技术的代码搜索（IR-based）工具存在两个问题： 自然语言查询中反映出的高级意图和源代码中的低层次实现细节不匹配 它们两者之间没有共同的词汇标记(lexical tokens)，同义词(synonyms)或者语言结构(language structures)，对于符合搜索条件的代码片段，但是没有在代码中出现相关关键词或者同义词，可能仅仅是语义上的相关（semantically related）时, 这种方法就无能为力了。 不能很好地处理不相关的关键词以及噪声词语（不能很好地理解查询意图） 举个例子，现在有一个查询 &quot;read an object from an xml&quot; ，以下代码片段符合是搜索条件的：1234567891011public static &lt; S &gt; S deserialize(Class c, File xml)&#123; try&#123; JAXBContext context = JAXBContext.newInstance(c); Unmarshaller unmarshaller = context.creatUnmarshaller(); S deserialize = (S) unmarshaller.unmarshal(xml); return deserialized; &#125; catch (JAXBException ex) &#123; log.error("Error-deserializing-object-from-xml", ex); return null; &#125;&#125; 然而，对于上述代码，IR-based 大概率是搜索不出来的，因为代码不包含诸如 read、object之类的关键词，也没有load、instance这样的同义词。因此，一个有效的代码搜索工具需要在代码和自然语言查询之间进行更高级别的映射。 深度学习的方法旨在解决这两个问题。深度学习的优势在于，可以学习查询的语义以及相应的 API 序列，以及去除不相关关键词的影响。在语义层面上，能比现有的方法更好地理解用户需要什么样的代码。 搜索源代码比生成相关API要困难得多，因为代码片段的语义不仅与API序列相关，而且与源代码的其他方面（如标记和方法名称）相关。如：对于&quot;save image as png&quot;以及&quot;save image as jpg&quot;这两个查询，DeepAPI会返回相同的API也就是imageIO.write，然而，根据源代码的相关标记，这两个查询实际的代码片段是不一样的。这也就要求深度学习的模型能够诠释源代码的更多方面。 论文就提出了一种新的模型叫做CODEnn(Code-Description Embedding Neural Network)，目的是把自然语言描述和代码片段嵌入到一个高维度的向量空间中，通过这种方式，二者就有了一个相似的向量表示，可以根据它们的向量来检索与自然语言查询在语义上相关的代码片段，还可以识别语义相关的单词，并且处理查询中的不相关/噪声关键字。 基于这种CODEnn模型，论文实现了一种代码搜索工具DeepCS，DeepCS使用GitHub上的1820万个Java代码片段训练CODEnn模型，然后它从代码库中读取代码片段，并使用经过训练的CODEnn模型将它们嵌入到高维度向量中。最后，当用户查询到达时，DeepCS会找出和查询向量距离最近的代码片段并返回。模型通过50个从Stack Overflow获得的真实查询进行验证，验证显示，查询结果比使用Code-How或者Lucene(两种传统代码搜索工具)的效果好一些。 接下来首先介绍一下相关技术，再阐述工具的设计和实现。 1.嵌入技术（Embedding Techniques）嵌入技术用来学习实体（如单词、句子、图像）的向量表示，使得相似的实体具有相似的向量。例如，execute的表示为[0.12, -0.32, 0.01]，而 run 的向量表示为[0.12, -0.31, 0.02]，从向量上我们可以估计他们的距离，确定他们之间的语义关系。字嵌入通常使用CBOW和Skip-Gram模型，模型构建了一个神经网络，用于捕捉单词及其上下文单词之间的关系，单词的向量表示作为神经网络的参数，并用文本语料库进行训练。 2.用于序列嵌入的递归神经网络（Recurrent Neural Networks）递归神经网络（RNN）是两种人工神经网络的总称。一种是时间递归神经网络（recurrent neural network），又名循环神经网络，另一种是结构递归神经网络（recursive neural network）。时间递归神经网络代表信息在时间维度从前往后的的传递和累积，在神经网络结构上表现为：前面的NN的隐藏层的输出作为后面的NN的隐藏层的输入。而结构递归神经网络是在空间维度上的展开。利用相似的神经网络结构递归构造更为复杂的深度网络。RNN一般指代时间递归神经网络。在此只作一下简单的介绍，关于二者的具体区别可以参考一下这个quora上的回答。以下的RNN统一指的是循环神经网络。在此对于RNN的基础理论不作过多介绍，如果你不知道RNN是什么，需要先了解一下有关RNN的基本理论知识。 我们可以利用RNN，对自然语句这样的序列数据进行嵌入，RNN的基本结构如图a所示。神经网络包括三层，输入层将每个输入映射为向量，循环隐藏层在读取每个输入之后循环计算和更新隐藏状态，输出层把隐藏状态应用于特定的任务。与传统的前馈神经网络不同，RNN可以利用其内部的存储嵌入一些顺序输入，比如句子。图b就是将句子嵌入到一个向量中的例子，通常来说也是图a的展开形式。 综上，我们把一段序列数据定义为多个单词的集合：s=w1, …,wT，然后通过如下过程将序列表示为向量。 从序列中逐个读入单词 wt, 每读入一个单词，更新隐藏层状态 ht 每个单词 wt，都通过one-hot表示或者字嵌入技术，被映射为一个d维的向量，每次 ht 的更新都是根据当前单词的输入 wt 和 ht-1 完成的。 整个过程完成后，得到一系列的隐藏层状态 h* ,一般来说，取最后的状态 ht 作为句子的向量表示，也可以将所有隐藏层状态矩阵作 max-pooling 得到最终向量表示。图示如下： 3. 联合嵌入(Joint embedding)自然语言描述和代码片段,两种数据的构成是不同的，所以无法简单的通过文本流匹配到一起（之前的方法把代码看做文本，仅通过关键词匹配等直接的手段，可以视为二者是同构的）。要想考虑代码片段的多方面因素（前文提到的API、tokens等），需要以一种新的方式去看待代码和自然语言查询。于是，联合嵌入应运而生，联合嵌入将二者嵌入到同一个向量空间中去，换算成统一的、向量形式的表示，这样，代码片段的各方面特征便不会丢失。 明确了相关技术之后，下一步就是设计一种用于代码搜索的深度神经网络。 CODEnn结构设计(Code Description Embedding Neural Network)CODEnn结构如下图所示： 该网络由两部分构成,COnn(code embedding network)将代码表示为向量,DEnn(description embedding network)把自然语言描述表示为向量。代码和描述分别经过RNN处理、maxpooling采样之后，得到最终向量，然后进行相似度比较。 训练集在训练之前，首先要对训练数据进行预处理。 数据收集： 训练数据来自github上开源项目中有文档注释的Java方法（/* 和 /之间的部分），如果该代码片段符合Java编程规范，那么文档注释的第一句是可以用来作该代码片段的自然语言描述的。且可以提取方法的有关声明作为代码元素。 最终，去掉0个star的和没有文档说明的一部分，得到 1823.3872 万的Java代码片段作为训练语料库。 抽取数据元组：&lt; method name, API sequence, tokens, description&gt; method name：利用驼峰命名法则的特点把 函数名 解析成一系列的标记（a sequence of tokens），listFiles –&gt; list, Files API sequence：使用Eclipse JDT编译器解析和遍历AST，有着一系列的规则和过程，比如，new C()，API序列就是 C.new tokens：从方法中，还是根据驼峰命名，分割出token，然后去掉休止词the，in这些，还有去掉源码中的Java关键词 description：使用Eclipse JDT编译器解析AST，从AST中抽取JavaDoc 下图是抽取的数据元组示例： 训练和评估训练：DeepCS的工作流是：离线训练模型，离线代码和描述嵌入，在线代码搜索，如图： 训练过程输入：&lt; C, D+, D-&gt; 训练模型输出：余弦相似度 输入元组均为向量表示,其中 D+ 为正确描述，D- 为错误表示，注意：D+和D-均来自训练数据。 评估：构造验证集：从github中选择至少获得20个star的、不在语料库之中的Java项目，包括没有JavaDoc的代码片段（训练集的代码片段包含自然语言描述）。最终共获得了 1626.2602 万个方法，对于每个方法，均抽取&lt; method name, API sequence, tokens&gt;，以此生成代码向量。 选择查询问题：从stackoverflow中Java编程问题的标签中选top 50并排序，找出其中有具体代码片段的回答。 性能评估：采用四种量化标准–FRank, SuccessRate@k, Precision@k,Mean Reciprocal Rank (MRR) FRank 指第一个匹配到的结果在查询结果列表中的排名数，越小代表越好。 工具之间的比较：Lucene、CodeHow—FRank值DeepCS为3.5，CH为5.5，Lucene为6.0. 不足之处DeepCS考虑到了查询的语义层面，不仅仅是关键词的匹配，这带来了性能上的很大提升，但是DeepCS也会出现查询到不相关的结果的情况，这很大程度上是因为，考虑到的影响查询结果的因素不够全面，如果把更多的代码层面的特征纳入代码向量中，比如程序的上下文，可以让工具变得更为可用。 除此之外，在评估阶段，是由两名开发者手工比对查询结果以及从stackoverflow筛选正确的匹配，不可避免地出现有分歧的情况，虽然通过多次的讨论解决了这种分歧，后续让更多的开发者参与评估会一定程度上提升结果的准确性。 另外，结果只是从stackoverflow进行评估，具有一定的片面性，后期会加入更多的权威搜索引擎及网站，达到更好的效果。 last edit at 2018/08/22 by haining]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法的基本示例]]></title>
    <url>%2Fpublic%2Fmarkdown-demo%2F</url>
    <content type="text"><![CDATA[本文是对如何在 Hexo 下的 NexT 主题中写 Markdown 文件的介绍，其中大部分是 Markdown 的基础语法，还有一些是 NexT 主题自带的特性。 在此查看和下载 markdown-demo.md源文件 正文参考如下，采用 代码 + 效果 的方式展示：1234567Text can be **bold**, _italic_, or ~~strikethrough~~.[Link to another page](./another-page.html).There should be whitespace between paragraphs.There should be whitespace between paragraphs. We recommend including a README... Text can be bold, italic, or strikethrough. Link to another page. There should be whitespace between paragraphs. There should be whitespace between paragraphs. We recommend including a README… 123456789101112131415161718# Header 1This is a normal paragraph following a header. ## Header 2&gt; This is a blockquote following a header.&gt;&gt; When something is important enough, you do it even if the odds are not in your favor.### Header 3```js// Javascript code with syntax highlighting.var fun = function lang(l) &#123; dateformat.i18n = require(&apos;./lang/&apos; + l) return true;&#125; Header 1This is a normal paragraph following a header. Header 2 This is a blockquote following a header. When something is important enough, you do it even if the odds are not in your favor. Header 312345// Javascript code with syntax highlighting.var fun = function lang(l) &#123; dateformat.i18n = require('./lang/' + l) return true;&#125; 1234# Ruby code with syntax highlightingGitHubPages::Dependencies.gems.each do |gem, version| s.add_dependency(gem, "= #&#123;version&#125;")end 12345678910111213141516171819202122232425#### Header 4* This is an unordered list following a header.* This is an unordered list following a header.* This is an unordered list following a header.##### Header 51. This is an ordered list following a header.2. This is an ordered list following a header.3. This is an ordered list following a header.###### Header 6| head1 | head two | three ||:-------------|:------------------|:------|| ok | good swedish fish | nice || out of stock | good and plenty | nice || ok | good `oreos` | hmm || ok | good `zoute` drop | yumm |### There&apos;s a horizontal rule below this.* * * Header 4 This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header. Header 5 This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header. Header 6 head1 head two three ok good swedish fish nice out of stock good and plenty nice ok good oreos hmm ok good zoute drop yumm There’s a horizontal rule below this. 123456789101112131415161718192021222324252627282930313233343536373839### Here is an unordered list:* Item foo* Item bar* Item baz* Item zip### And an ordered list:1. Item one1. Item two1. Item three1. Item four### And a nested list:#### 不同 level 之间是两个空格- level 1 item - level 2 item - level 2 item - level 3 item - level 3 item- level 1 item - level 2 item - level 2 item - level 2 item- level 1 item - level 2 item - level 2 item- level 1 item### Small image![Octocat](https://assets-cdn.github.com/images/icons/emoji/octocat.png)### Large image![Branching](https://guides.github.com/activities/hello-world/branching.png) Here is an unordered list: Item foo Item bar Item baz Item zip And an ordered list: Item one Item two Item three Item four And a nested list:不同 level 之间是两个空格 level 1 item level 2 item level 2 item level 3 item level 3 item level 1 item level 2 item level 2 item level 2 item level 1 item level 2 item level 2 item level 1 item Small image Large image 1234567891011121314151617181920### Definition lists can be used with HTML syntax.&lt;dl&gt;&lt;dt&gt;Name&lt;/dt&gt;&lt;dd&gt;Godzilla&lt;/dd&gt;&lt;dt&gt;Born&lt;/dt&gt;&lt;dd&gt;1952&lt;/dd&gt;&lt;dt&gt;Birthplace&lt;/dt&gt;&lt;dd&gt;Japan&lt;/dd&gt;&lt;dt&gt;Color&lt;/dt&gt;&lt;dd&gt;Green&lt;/dd&gt;&lt;/dl&gt;`` `Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.`` ``` `The final element.`` ` Definition lists can be used with HTML syntax.NameGodzillaBorn1952BirthplaceJapanColorGreen 1Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. 1The final element. 以上就是 Markdown 基本语法，除此之外，NexT 主题自带了一些效果。插入一段音频：12 update at: 2018/07/12]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo备忘录]]></title>
    <url>%2Fpublic%2FHexo_memo%2F</url>
    <content type="text"><![CDATA[Hexo基本指令这是我的博客的第一篇文章，以后会多在这里分享一些我的成长和感悟。 在当前文件夹建立并初始化一个网站1hexo init layout为页面布局，默认是在_config.yml文件里设置的布局，此命令新建一篇文章1hexo new [layout] &quot;title&quot; 清除数据库和 public 也就是准备发布到服务器上的文件夹1hexo clean 生成网站静态文件1hexo g 发表为草稿1hexo publish &quot;title&quot; 部署到本地服务器，打开http://localhost:4000/即可查看1hexo s 部署到 usrname.github.io，也就是你的github上。1hexo d 运行此命令需要事先安装 hexo-deployer-git ，在命令行输入如下命令： 1npm install hexo-deployer-git --save 安装完成之后，在_config,yml中配置deploy：123deploy: type: git repo: your github address 更多设置参见Hexo指令Last Edit : 2018.07.11]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode | Roman to Integer]]></title>
    <url>%2Fpublic%2F13_Roman_to_Integer%2F</url>
    <content type="text"><![CDATA[13. Roman to IntegerRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: “III”Output: 3Example 2: Input: “IV”Output: 4Example 3: Input: “IX”Output: 9Example 4: Input: “LVIII”Output: 58Explanation: L = 50, V= 5, III = 3.Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 刚开始我写了一种，简单粗暴：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: /** * roman to int * @hainingbaby * @Time 2019-04-10T22:21:24+0800 * @param s [description] * @return [description] */ int romanToInt(string s) &#123; int res = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if(s[i] == 'I') res += 1; if(s[i] == 'V') if(i &gt; 0 &amp;&amp; s[i-1] == 'I') res += 3; else res += 5; if(s[i] == 'X') if(i &gt; 0 &amp;&amp; s[i-1] == 'I') res += 8; else res += 10; if(s[i] == 'L') if(i &gt; 0 &amp;&amp; s[i-1] == 'X') res += 30; else res += 50; if(s[i] == 'C') if(i &gt; 0 &amp;&amp; s[i-1] == 'X') res += 80; else res += 100; if(s[i] == 'D') if(i &gt; 0 &amp;&amp; s[i-1] == 'C') res += 300; else res += 500; if(s[i] == 'M') if(i &gt; 0 &amp;&amp; s[i-1] == 'C') res += 800; else res += 1000; &#125; return res; &#125;&#125;; 提交之后的结果： 后来网上搜了一下，简直优美，我写不出来的原因就是脑子里连基本的Map概念都没有…. Solution 2:12345678910111213141516class Solution &#123;public: int romanToInt(string s) &#123; map&lt;char, int&gt; m&#123;&#123;&apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125;&#125;; int res = 0; for (int i = 0; i &lt; s.length(); i++) &#123; res += m[s[i]]; if (i &gt; 0 &amp;&amp; m[s[i]] &gt; m[s[i - 1]]) res -= 2 * m[s[i - 1]]; &#125; return res; &#125;&#125;; 但是跑出来的结果是： 对于这种简单的枚举问题有时候简单粗暴可能更节省资源..]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[defects4j对lang-55的软件测试小体验]]></title>
    <url>%2Fpublic%2Fdefects4j-lang55%2F</url>
    <content type="text"><![CDATA[defects4j Lang-55 bug修复0x01 发现bug搭建好defects4j环境之后，运行命令： 12defects4j compiledefects4j test 发现 StopWatchTest::testLang315 的测试例未通过: 通过failing_tests中的提示信息，从文件夹中找到对应的测试例代码，定位到出错的测试样例。 testLang315出错测试例： 发现大概率是 stopWatch 类中 start/suspend/stop 某一个出了问题，查看源码： 由此可见，在测试例testLang315中，当调用suspend方法时，对stopTime进行了一次写操作，系统状态转为suspend，而之后在stop中又对stopTime进行了一次写操作从而使得stopTime发生了改变，导致suspendTime和totalTime不一致。 0x02 修复bug只需要在stop方法中，在对stopTime进行写操作之前，对其状态进行判断即可，当状态为suspend的时候，不对其进行写操作，避免overwrite，在此使用两种修复办法。 方法1：在写操作之前加上对系统当前状态的判断： 方法2：发生bug的本质原因是stopTime属性的overwrite，注意到在start方法里每次的start 都会把stopTime 重置为-1。所以，可以利用如下判断： 0x03 修复结果上述两种方法均能修复bug，修改之后重新编译测试，结果如下:]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用深度学习找到你想要的代码]]></title>
    <url>%2Fpublic%2FDeepCS%2F</url>
    <content type="text"><![CDATA[这篇文章是对2018年发表在ICSE上的论文《Deep code search》的解析，原文链接在此。 综述论文中，作者利用深度学习技术实现了一种代码搜索工具 DeepCS，其主要特点可总结为如下几个方面： 以往的代码搜索工具，比如CodeHow、Lucene等，基本上都是基于信息检索技术，将代码看做文本文档，通过匹配文本或者代码API的相似性，来找到和自然语言查询所对应的代码片段。 这种方法存在一些问题，比如仅通过关键词这些较为直接和表层的方面来完成一次搜索匹配（当然这种方法也是有效的），没有充分考虑和利用到「自然语言查询语句」和「代码片段」在语义上的关系。文章提出的新的代码搜索方案考虑到了两者的多个关联层面，综合了代码的方法名称、API序列、标记等各个方面，力求在语义上更好地理解代码查询的过程。 提出联合嵌入的思路，将 代码片段 和 自然语言查询语句利用字嵌入或者one-hot表示为统一维度的向量，通过向量的余弦相似度来衡量二者之间的相似性也就是匹配程度。 提出了一种新型的人工神经网络CODEnn(Code Description Embedding Neural Network),COnn用来将一个代码片段映射为向量，DEnn用于将自然语言描述映射为向量，经过给定格式数据元组对CODEnn进行训练之后，该网络可以自动将任一代码片段或者描述映射为向量。 DeepCS使用了两种深度学习的框架进行实现：keras和pytorch，具体环境为: Ubuntu 16.04 Python 2.7-3.6 Keras 2.0 or newer Tensorflow or Theano 0.8.0~0.9.1. 原理论文提出的基于深度学习的代码搜索工具的实现思路如下： 收集训练数据：从github中，结合一定的条件，筛选出符合要求的Java代码片段 离线训练模型：从获得的代码片段中，抽取相关信息，构造训练数据元组。输入模型的是代码和描述两种数据元组，经过RNN以及池化层特征采样，输出两个高维的向量，并进一步通过二者的比较输出余弦相似度，最终得到可用的CODEnn 离线代码嵌入：此处的代码嵌入指的是，对我们要进行搜索的代码库进行嵌入（同样从github中获取，但和训练库相异），也就是经过COnn将代码表示为正确的向量形式，得到一个代码向量库 在线代码搜索：当一次查询到来时，首先经过DEnn将查询表示为向量，然后把这个向量和之前得到的代码向量库作相似度比较，得到想要的代码片段。 论文提出的代码搜索工具的工作方式为：用户在线搜索，输入查询描述语句，后台经过DEnn表示成向量，和使用COnn事先得到的代码向量库作余弦相似度比较，最终返回相似度最大的top K作为查询结果。 效果工具的在线演示demo效果如下图：工具的在线运行demo暂时不可用.. 下面对论文进行详解： 基于信息检索技术的代码搜索（IR-based）工具存在两个问题： 自然语言查询中反映出的高级意图和源代码中的低层次实现细节不匹配 它们两者之间没有共同的词汇标记(lexical tokens)，同义词(synonyms)或者语言结构(language structures)，对于符合搜索条件的代码片段，但是没有在代码中出现相关关键词或者同义词，可能仅仅是语义上的相关（semantically related）时, 这种方法就无能为力了。 不能很好地处理不相关的关键词以及噪声词语（不能很好地理解查询意图） 举个例子，现在有一个查询 &quot;read an object from an xml&quot; ，以下代码片段符合是搜索条件的：1234567891011public static &lt; S &gt; S deserialize(Class c, File xml)&#123; try&#123; JAXBContext context = JAXBContext.newInstance(c); Unmarshaller unmarshaller = context.creatUnmarshaller(); S deserialize = (S) unmarshaller.unmarshal(xml); return deserialized; &#125; catch (JAXBException ex) &#123; log.error("Error-deserializing-object-from-xml", ex); return null; &#125;&#125; 然而，对于上述代码，IR-based 大概率是搜索不出来的，因为代码不包含诸如 read、object之类的关键词，也没有load、instance这样的同义词。因此，一个有效的代码搜索工具需要在代码和自然语言查询之间进行更高级别的映射。 深度学习的方法旨在解决这两个问题。深度学习的优势在于，可以学习查询的语义以及相应的 API 序列，以及去除不相关关键词的影响。在语义层面上，能比现有的方法更好地理解用户需要什么样的代码。 搜索源代码比生成相关API要困难得多，因为代码片段的语义不仅与API序列相关，而且与源代码的其他方面（如标记和方法名称）相关。如：对于&quot;save image as png&quot;以及&quot;save image as jpg&quot;这两个查询，DeepAPI会返回相同的API也就是imageIO.write，然而，根据源代码的相关标记，这两个查询实际的代码片段是不一样的。这也就要求深度学习的模型能够诠释源代码的更多方面。 论文就提出了一种新的模型叫做CODEnn(Code-Description Embedding Neural Network)，目的是把自然语言描述和代码片段嵌入到一个高维度的向量空间中，通过这种方式，二者就有了一个相似的向量表示，可以根据它们的向量来检索与自然语言查询在语义上相关的代码片段，还可以识别语义相关的单词，并且处理查询中的不相关/噪声关键字。 基于这种CODEnn模型，论文实现了一种代码搜索工具DeepCS，DeepCS使用GitHub上的1820万个Java代码片段训练CODEnn模型，然后它从代码库中读取代码片段，并使用经过训练的CODEnn模型将它们嵌入到高维度向量中。最后，当用户查询到达时，DeepCS会找出和查询向量距离最近的代码片段并返回。模型通过50个从Stack Overflow获得的真实查询进行验证，验证显示，查询结果比使用Code-How或者Lucene(两种传统代码搜索工具)的效果好一些。 接下来首先介绍一下相关技术，再阐述工具的设计和实现。 1.嵌入技术（Embedding Techniques）嵌入技术用来学习实体（如单词、句子、图像）的向量表示，使得相似的实体具有相似的向量。例如，execute的表示为[0.12, -0.32, 0.01]，而 run 的向量表示为[0.12, -0.31, 0.02]，从向量上我们可以估计他们的距离，确定他们之间的语义关系。字嵌入通常使用CBOW和Skip-Gram模型，模型构建了一个神经网络，用于捕捉单词及其上下文单词之间的关系，单词的向量表示作为神经网络的参数，并用文本语料库进行训练。 2.用于序列嵌入的递归神经网络（Recurrent Neural Networks）递归神经网络（RNN）是两种人工神经网络的总称。一种是时间递归神经网络（recurrent neural network），又名循环神经网络，另一种是结构递归神经网络（recursive neural network）。时间递归神经网络代表信息在时间维度从前往后的的传递和累积，在神经网络结构上表现为：前面的NN的隐藏层的输出作为后面的NN的隐藏层的输入。而结构递归神经网络是在空间维度上的展开。利用相似的神经网络结构递归构造更为复杂的深度网络。RNN一般指代时间递归神经网络。在此只作一下简单的介绍，关于二者的具体区别可以参考一下这个quora上的回答。以下的RNN统一指的是循环神经网络。在此对于RNN的基础理论不作过多介绍，如果你不知道RNN是什么，需要先了解一下有关RNN的基本理论知识。 我们可以利用RNN，对自然语句这样的序列数据进行嵌入，RNN的基本结构如图a所示。神经网络包括三层，输入层将每个输入映射为向量，循环隐藏层在读取每个输入之后循环计算和更新隐藏状态，输出层把隐藏状态应用于特定的任务。与传统的前馈神经网络不同，RNN可以利用其内部的存储嵌入一些顺序输入，比如句子。图b就是将句子嵌入到一个向量中的例子，通常来说也是图a的展开形式。 综上，我们把一段序列数据定义为多个单词的集合：s=w1, …,wT，然后通过如下过程将序列表示为向量。 从序列中逐个读入单词 wt, 每读入一个单词，更新隐藏层状态 ht 每个单词 wt，都通过one-hot表示或者字嵌入技术，被映射为一个d维的向量，每次 ht 的更新都是根据当前单词的输入 wt 和 ht-1 完成的。 整个过程完成后，得到一系列的隐藏层状态 h* ,一般来说，取最后的状态 ht 作为句子的向量表示，也可以将所有隐藏层状态矩阵作 max-pooling 得到最终向量表示。图示如下： 3. 联合嵌入(Joint embedding)自然语言描述和代码片段,两种数据的构成是不同的，所以无法简单的通过文本流匹配到一起（之前的方法把代码看做文本，仅通过关键词匹配等直接的手段，可以视为二者是同构的）。要想考虑代码片段的多方面因素（前文提到的API、tokens等），需要以一种新的方式去看待代码和自然语言查询。于是，联合嵌入应运而生，联合嵌入将二者嵌入到同一个向量空间中去，换算成统一的、向量形式的表示，这样，代码片段的各方面特征便不会丢失。 明确了相关技术之后，下一步就是设计一种用于代码搜索的深度神经网络。 CODEnn结构设计(Code Description Embedding Neural Network)CODEnn结构如下图所示： 该网络由两部分构成,COnn(code embedding network)将代码表示为向量,DEnn(description embedding network)把自然语言描述表示为向量。代码和描述分别经过RNN处理、maxpooling采样之后，得到最终向量，然后进行相似度比较。 训练集在训练之前，首先要对训练数据进行预处理。 数据收集： 训练数据来自github上开源项目中有文档注释的Java方法（/* 和 /之间的部分），如果该代码片段符合Java编程规范，那么文档注释的第一句是可以用来作该代码片段的自然语言描述的。且可以提取方法的有关声明作为代码元素。 最终，去掉0个star的和没有文档说明的一部分，得到 1823.3872 万的Java代码片段作为训练语料库。 抽取数据元组：&lt; method name, API sequence, tokens, description&gt; method name：利用驼峰命名法则的特点把 函数名 解析成一系列的标记（a sequence of tokens），listFiles –&gt; list, Files API sequence：使用Eclipse JDT编译器解析和遍历AST，有着一系列的规则和过程，比如，new C()，API序列就是 C.new tokens：从方法中，还是根据驼峰命名，分割出token，然后去掉休止词the，in这些，还有去掉源码中的Java关键词 description：使用Eclipse JDT编译器解析AST，从AST中抽取JavaDoc 下图是抽取的数据元组示例： 训练和评估训练：DeepCS的工作流是：离线训练模型，离线代码和描述嵌入，在线代码搜索，如图： 训练过程输入：&lt; C, D+, D-&gt; 训练模型输出：余弦相似度 输入元组均为向量表示,其中 D+ 为正确描述，D- 为错误表示，注意：D+和D-均来自训练数据。 评估：构造验证集：从github中选择至少获得20个star的、不在语料库之中的Java项目，包括没有JavaDoc的代码片段（训练集的代码片段包含自然语言描述）。最终共获得了 1626.2602 万个方法，对于每个方法，均抽取&lt; method name, API sequence, tokens&gt;，以此生成代码向量。 选择查询问题：从stackoverflow中Java编程问题的标签中选top 50并排序，找出其中有具体代码片段的回答。 性能评估：采用四种量化标准–FRank, SuccessRate@k, Precision@k,Mean Reciprocal Rank (MRR) FRank 指第一个匹配到的结果在查询结果列表中的排名数，越小代表越好。 工具之间的比较：Lucene、CodeHow—FRank值DeepCS为3.5，CH为5.5，Lucene为6.0. 不足之处DeepCS考虑到了查询的语义层面，不仅仅是关键词的匹配，这带来了性能上的很大提升，但是DeepCS也会出现查询到不相关的结果的情况，这很大程度上是因为，考虑到的影响查询结果的因素不够全面，如果把更多的代码层面的特征纳入代码向量中，比如程序的上下文，可以让工具变得更为可用。 除此之外，在评估阶段，是由两名开发者手工比对查询结果以及从stackoverflow筛选正确的匹配，不可避免地出现有分歧的情况，虽然通过多次的讨论解决了这种分歧，后续让更多的开发者参与评估会一定程度上提升结果的准确性。 另外，结果只是从stackoverflow进行评估，具有一定的片面性，后期会加入更多的权威搜索引擎及网站，达到更好的效果。 last edit at 2018/08/22 by haining]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu变形记-unity变身gnome]]></title>
    <url>%2Fpublic%2Fgnome-conf%2F</url>
    <content type="text"><![CDATA[ubunt16.04桌面从 unity 变为 gnome花了一天时间折腾了我的一下桌面，踩了不少坑，记录一下，以备以后换电脑再折腾。 效果图 关于配置： gnome-tweak-tool配置 gnome-shell-extensions推荐 友情链接 部分爬坑指南 Top 20 GNOME Extensions You Should Be Using Right Now 下面开始折腾： 0x01 在命令行安装sudo add-apt-repository ppa:gnome3-team/gnome3 sudo apt-get update sudo apt-get upgrade sudo apt-get dist-upgrade sudo apt-get install gnome-session-flashback sudo apt-get install gnome-tweak-tool sudo apt-get install gnome-shell sudo apt-get install gnome-shell-extensions 如果用我推荐的主题的话，这里推荐选metacity，我之前用的gnome classic非常爆炸，后边会提到。选择GNOME Flashback： 现在，你可以轻松的在Unity和Gnome桌面之间切换。 0x02 遇到的问题 安装时遇到依赖问题，报错显示某依赖包的已安装版本过高，正确解决办法是先卸载有依赖问题的包pkg： sudo apt-get remove [pkg]然后重新运行0x01中出错的命令，这样他就会重新下载对应版本的依赖包。 在gnome环境下操作的时候，不要随便删与gnome相关的包，不然可能连渣都不剩，我运气好，当时遇到了问题，全删了，结果啥都没有了，后来不放弃重新安装了一遍，莫名其妙好了，我猜是因为我安装的主题针对metacity这种gnome作了css优化，但我操作都是在一个gnome-classic环境里进行的，所以出了问题。 0x03 安装之后接下来就是使用gnome-shell-extensions进行桌面优化。所使用的插件见上方效果图和链接。 last update at: 2019/04/01 by haining]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <url>%2Fpublic%2Fleetcode%2F</url>
    <content type="text"><![CDATA[leetcode题目，持续更新 448. Find All Numbers Disappeared in an Array. Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input:[4,3,2,7,8,2,3,1] Output:[5,6] 解：在一个整数数组中找出所有未出现过的数并输出，要求时间复杂度O(n),而且不浪费额外的空间。正常的思路是两个循环解决问题。空间上不多余，但时间复杂度是0(n^2)。考虑到是一个整数数组，可以利用索引与本身数值的关系。 如果这个数组是顺序排列的那就好了，我只需要判断索引 i 的值是不是 i+1（num[i] == i+1)，就能知道这个数在不在数组里。然后得出结果就行了。 问题的关键就在于，数组不是顺序排列的，这个简单的判断方法不好使了，之前是按照索引找数值，因为本题情况的特殊化，可不可以按照数值找索引呢？ 也就是说，一个整数数组[4,3,2,7,8,2,3,1]，有 4 这个数值，就意味着，在顺序排列的数组里，num[3]是可以映射到4的（num[3]==4），有 3 这个数值，那么num[2]可以映射到3（num[2]==3），有 num[i]这个数值，那么 num[ num[i]-1 ] 可以映射到num[i]。所以，是不是遍历一次这个数组，如果有个整数不在这个数组里边，那么我们就无法对他作出处理，使其在顺序数组里索引和数值相对应？ 所以，思路有了： 遍历一遍数组，对于每一个整数num[i]，把这个整数，在假设的顺序排列数组里的索引，也就是「num[i]-1」（注意，这是一个索引）做上标记，目的是和没有出现在数组里的整数的索引区分开来。 再遍历一遍（这个数组或者你自己新建的数组，后边会解释），根据标记，返回最终结果。 怎么做标记区分开出现的和没出现的整数？举两个例子。 新建一个数组a，初始化为1，见到第一个数4，把a[3]改为0，见到3，把a[2]改为0，见到2把a[1]改为0，依次继续。突然，见到了第二个2出现了，这时候改不改都无所谓，因为a[2]已经是0了。注意，这个地方的数字本来应该是缺少的那一个，也就是我们寻找的结果，是几呢，5，所以他本来应该把a[4]改成0，但是现在没有改。所以，再遍历一次你新建的a数组，哪个索引 i 对应的数值是 1 ，则 i+1 就是我们要找的那个未出现在数组里的整数（因为我们利用了顺序数组的性质进行的改值操作）。 方法1自己开辟了一个数组a，能不能在原数组上改呢？能，改成原来值的负值是一个不错的选择，虽然我们根本不关心它的值为负还是为0，只是需要区分在其中的整数和不在其中的整数的区别罢了。但是在把当前数值转换成索引的时候会变动后边的数值，取负值可以用绝对值函数abs，不影响后边的变换。改成0就不行了。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; for(int i = 0 ; i &lt; nums.size(); i++)&#123; int index = abs(nums[i])-1; if(nums[index]&gt;0) nums[index] = -nums[index]; &#125; for(int j=0; j&lt; nums.size(); j++)&#123; if(nums[j] &gt; 0) res.push_back(j+1); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Github中Fork了一个仓库，如何在这个仓库变化之后，仍然保持代码一致]]></title>
    <url>%2Fpublic%2Fgithub-mem%2F</url>
    <content type="text"><![CDATA[github操作备忘 0X01.假设要Fork的别人的repo为 A ，Fork到你的github之后叫做 a ，现在别人对 A 进行了更新，和 a 不一致了。如何保持一致？ 克隆 a 到本地 1git clone a的github地址 在本地添加最新的 A 为一个分支 1git remote add upstram [原项目地址] 其中upstream是自己任起的分支名字，一般用这个表示最上游分支。 fetch 这个最新的 A 到本地 1git fetch upstream 接下来要merge两个分支，先确保你现在已经处于要merge到的master分支下边(或者不是master是你自己的分支) 1git checkout master merge 1git merge upstream/master 推送到自己的github仓库 1git push origin master 结束。 0X02.在本地修改之后如何撤销？ 方法1：123git checkout . #撤销对所有已修改但未提交的文件的修改，但不包括新增的文件git checkout [filename] #撤销对指定文件的修改 方法二：1git reset --hard [commit id] #commit id 通过 git log查看]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法的基本示例]]></title>
    <url>%2Fpublic%2Fmarkdown-demo%2F</url>
    <content type="text"><![CDATA[本文是对如何在 Hexo 下的 NexT 主题中写 Markdown 文件的介绍，其中大部分是 Markdown 的基础语法，还有一些是 NexT 主题自带的特性。 在此查看和下载 markdown-demo.md源文件 正文参考如下，采用 代码 + 效果 的方式展示：1234567Text can be **bold**, _italic_, or ~~strikethrough~~.[Link to another page](./another-page.html).There should be whitespace between paragraphs.There should be whitespace between paragraphs. We recommend including a README... Text can be bold, italic, or strikethrough. Link to another page. There should be whitespace between paragraphs. There should be whitespace between paragraphs. We recommend including a README… 123456789101112131415161718# Header 1This is a normal paragraph following a header. ## Header 2&gt; This is a blockquote following a header.&gt;&gt; When something is important enough, you do it even if the odds are not in your favor.### Header 3```js// Javascript code with syntax highlighting.var fun = function lang(l) &#123; dateformat.i18n = require(&apos;./lang/&apos; + l) return true;&#125; Header 1This is a normal paragraph following a header. Header 2 This is a blockquote following a header. When something is important enough, you do it even if the odds are not in your favor. Header 312345// Javascript code with syntax highlighting.var fun = function lang(l) &#123; dateformat.i18n = require('./lang/' + l) return true;&#125; 1234# Ruby code with syntax highlightingGitHubPages::Dependencies.gems.each do |gem, version| s.add_dependency(gem, "= #&#123;version&#125;")end 12345678910111213141516171819202122232425#### Header 4* This is an unordered list following a header.* This is an unordered list following a header.* This is an unordered list following a header.##### Header 51. This is an ordered list following a header.2. This is an ordered list following a header.3. This is an ordered list following a header.###### Header 6| head1 | head two | three ||:-------------|:------------------|:------|| ok | good swedish fish | nice || out of stock | good and plenty | nice || ok | good `oreos` | hmm || ok | good `zoute` drop | yumm |### There&apos;s a horizontal rule below this.* * * Header 4 This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header. Header 5 This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header. Header 6 head1 head two three ok good swedish fish nice out of stock good and plenty nice ok good oreos hmm ok good zoute drop yumm There’s a horizontal rule below this. 123456789101112131415161718192021222324252627282930313233343536373839### Here is an unordered list:* Item foo* Item bar* Item baz* Item zip### And an ordered list:1. Item one1. Item two1. Item three1. Item four### And a nested list:#### 不同 level 之间是两个空格- level 1 item - level 2 item - level 2 item - level 3 item - level 3 item- level 1 item - level 2 item - level 2 item - level 2 item- level 1 item - level 2 item - level 2 item- level 1 item### Small image![Octocat](https://assets-cdn.github.com/images/icons/emoji/octocat.png)### Large image![Branching](https://guides.github.com/activities/hello-world/branching.png) Here is an unordered list: Item foo Item bar Item baz Item zip And an ordered list: Item one Item two Item three Item four And a nested list:不同 level 之间是两个空格 level 1 item level 2 item level 2 item level 3 item level 3 item level 1 item level 2 item level 2 item level 2 item level 1 item level 2 item level 2 item level 1 item Small image Large image 1234567891011121314151617181920### Definition lists can be used with HTML syntax.&lt;dl&gt;&lt;dt&gt;Name&lt;/dt&gt;&lt;dd&gt;Godzilla&lt;/dd&gt;&lt;dt&gt;Born&lt;/dt&gt;&lt;dd&gt;1952&lt;/dd&gt;&lt;dt&gt;Birthplace&lt;/dt&gt;&lt;dd&gt;Japan&lt;/dd&gt;&lt;dt&gt;Color&lt;/dt&gt;&lt;dd&gt;Green&lt;/dd&gt;&lt;/dl&gt;`` `Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.`` ``` `The final element.`` ` Definition lists can be used with HTML syntax.NameGodzillaBorn1952BirthplaceJapanColorGreen 1Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. 1The final element. 以上就是 Markdown 基本语法，除此之外，NexT 主题自带了一些效果。插入一段音频：12 update at: 2018/07/12]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo备忘录]]></title>
    <url>%2Fpublic%2FHexo_memo%2F</url>
    <content type="text"><![CDATA[Hexo基本指令这是我的博客的第一篇文章，以后会多在这里分享一些我的成长和感悟。 在当前文件夹建立并初始化一个网站1hexo init layout为页面布局，默认是在_config.yml文件里设置的布局，此命令新建一篇文章1hexo new [layout] &quot;title&quot; 清除数据库和 public 也就是准备发布到服务器上的文件夹1hexo clean 生成网站静态文件1hexo g 发表为草稿1hexo publish &quot;title&quot; 部署到本地服务器，打开http://localhost:4000/即可查看1hexo s 部署到 usrname.github.io，也就是你的github上。1hexo d 运行此命令需要事先安装 hexo-deployer-git ，在命令行输入如下命令： 1npm install hexo-deployer-git --save 安装完成之后，在_config,yml中配置deploy：123deploy: type: git repo: your github address 更多设置参见Hexo指令Last Edit : 2018.07.11]]></content>
      <categories>
        <category>public</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
</search>
